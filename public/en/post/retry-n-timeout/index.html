<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Retry and  timeouts | vindurriel</title>
<meta name="keywords" content="aws, prose">
<meta name="description" content="Use cases
Achieve high availability (HA) from the standpoint of Users or Proxies
assuming that:

the failure of some attempt is temporary or localized to some of the workers
workers are redundant and interchangeable
there are enough time and workers

There are several types or levels of retrying:

A general control flow of retries:

Polling for a status change without knowing when it&rsquo;ll happen

Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.">
<meta name="author" content="">
<link rel="canonical" href="https://vindurriel.github.io/en/post/retry-n-timeout/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://vindurriel.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://vindurriel.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://vindurriel.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://vindurriel.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://vindurriel.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://vindurriel.github.io/en/post/retry-n-timeout/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://vindurriel.github.io/en/post/retry-n-timeout/">
  <meta property="og:site_name" content="vindurriel">
  <meta property="og:title" content="Retry and  timeouts">
  <meta property="og:description" content="Use cases Achieve high availability (HA) from the standpoint of Users or Proxies assuming that:
the failure of some attempt is temporary or localized to some of the workers workers are redundant and interchangeable there are enough time and workers There are several types or levels of retrying:
A general control flow of retries: Polling for a status change without knowing when itâ€™ll happen Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2021-08-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2021-08-24T00:00:00+00:00">
    <meta property="article:tag" content="Aws">
    <meta property="article:tag" content="Prose">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Retry and  timeouts">
<meta name="twitter:description" content="Use cases
Achieve high availability (HA) from the standpoint of Users or Proxies
assuming that:

the failure of some attempt is temporary or localized to some of the workers
workers are redundant and interchangeable
there are enough time and workers

There are several types or levels of retrying:

A general control flow of retries:

Polling for a status change without knowing when it&rsquo;ll happen

Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://vindurriel.github.io/en/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Retry and  timeouts",
      "item": "https://vindurriel.github.io/en/post/retry-n-timeout/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Retry and  timeouts",
  "name": "Retry and  timeouts",
  "description": "Use cases Achieve high availability (HA) from the standpoint of Users or Proxies assuming that:\nthe failure of some attempt is temporary or localized to some of the workers workers are redundant and interchangeable there are enough time and workers There are several types or levels of retrying:\nA general control flow of retries: Polling for a status change without knowing when it\u0026rsquo;ll happen Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.\n",
  "keywords": [
    "aws", "prose"
  ],
  "articleBody": "Use cases Achieve high availability (HA) from the standpoint of Users or Proxies assuming that:\nthe failure of some attempt is temporary or localized to some of the workers workers are redundant and interchangeable there are enough time and workers There are several types or levels of retrying:\nA general control flow of retries: Polling for a status change without knowing when itâ€™ll happen Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.\nModel Evaluate by:\nerror types (can recover by retrying?) number of attempts (max attempts reached?) time (timeout?) The definition of insanity is doing the same thing over and over again, but expecting different results.\nâ€“ Albert Einstein\nAdjust on:\ntime (sleep intervals) worker (pick another worker / let a load balancer decide) request size (response 413 or 429: split large requests into smaller ones) request data (User triggered, e.g. fix typo, input correct values) If the clients are many client retry strategy becomes a gaming problem, local optimization may cause overall crisis.\nrequest times (i.e wait intervals) should be randomized to avoid workload peaks resource contention and racing condition should be treated by both clients and the service instances eliminate unnecessary retries from both client and service side. Pros and cons for client retries Pros:\nallows client being resilient to partial / temporary failures allows client-driven async workflows (write, polling reads, another write) Cons:\nmay incur side effects (non-idempotent writes cause duplicate data) request multiplication is non-linear and positively related to service load and latency (cascading failures) may cause racing conditions or hot spots. To remediate the Cons, we need these technical capabilities on the service side:\nidempotent write APIs rate limits / circuit breakers / load balancing with warm-ups locks, queues and sharding Anti-patterns ( â€œDonâ€™t\"s ) Donâ€™t retry on all errors retry should be based on coded type of errors\nhttp status code:\n429 too many requests 503 service unavailable see the code in aws sdk retryer\nGRPC status code:\nUnavailable ResourceExhausted see the code in go-grpc retryer\nDonâ€™t retry instantly should wait with backoffs, especially when throttled\nsee the code in aws sdk retryer\nRetry-After in seconds:\n[0.045, 0.06, 0.09, 0.15, 0.27, 0.51, 0.99, 1.95, 3.87, 7.71, 15.39, 30.75, 61.47, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91] Donâ€™t retry on the fragile parts e.g. retry on Services, not on Pods; retry on domain names, not on ips\nDonâ€™t retry indefinitely when maximal time or attempts are exceeded:\ntrigger alarms manually ignore put to dead letter queue for later processing Guidelines (â€œDo\"s) retry on selected errors at the right level (user vs. client vs. proxy vs. worker) service should fail fast and explicit (allow downstream to decide should / how to retry) pass timeouts through context configurable retry parameters (max attempts, per-attempt timeout, retry-able error codes) apply back-pressure (TCP flow control, 429 responses, alarm triggering scaling and throttling actions) idempotent writes (avoid duplicate data) Cascading failures, the nightmare of system operators (SREs) positive feedback loop\nCase 1. DynamoDB OOS because GSI was introduced in 2015 https://aws.amazon.com/message/5467D2/\nhttps://www.infoq.com/articles/anatomy-cascading-failure/\nIf service capacity is not added quickly enough and the load balancing is naive (round-robin or least-conn), new capacities will be flooded quickly (domino effect)\nLessons learned:\navoid resource contention between client-facing requests and administrative ones sharding on metadata reduce retries to a lower rate Case 2. AWS us-east-1 down because Kinesis frontend fleet scaling out limitations https://aws.amazon.com/message/11201/\nthe issue was identified within 4 hours, but the recovery process (manually restarting servers in batches and ramping up workload) took over 17 hours.\nbecause if service capacity is added too quickly, there are significant resource contentions causing the new capacities to be unhealthy and taken down.\nLessons learned:\nhorizontal scaling may have unknown limits (open file handlers, thread counts, network bandwidth etc) that sometimes vertical scaling is required avoid resource contention on administrative and client-facing workloads avoid n-to-n synchronizations sharding on fleets ",
  "wordCount" : "659",
  "inLanguage": "en",
  "datePublished": "2021-08-24T00:00:00Z",
  "dateModified": "2021-08-24T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://vindurriel.github.io/en/post/retry-n-timeout/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "vindurriel",
    "logo": {
      "@type": "ImageObject",
      "url": "https://vindurriel.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://vindurriel.github.io/en/" accesskey="h" title="vindurriel (Alt + H)">vindurriel</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="https://vindurriel.github.io/" title="ç®€ä½“ä¸­æ–‡ ðŸ‡¨ðŸ‡³"
                                aria-label="ç®€ä½“ä¸­æ–‡ :cn:">ç®€ä½“ä¸­æ–‡ ðŸ‡¨ðŸ‡³</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://vindurriel.github.io/en/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://vindurriel.github.io/en/resume/" title="Resume">
                    <span>Resume</span>
                </a>
            </li>
            <li>
                <a href="https://vindurriel.github.io/en/index.xml" title="RSS feed">
                    <span>RSS feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://vindurriel.github.io/en/">Home</a>&nbsp;Â»&nbsp;<a href="https://vindurriel.github.io/en/post/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Retry and  timeouts
    </h1>
    <div class="post-meta"><span title='2021-08-24 00:00:00 +0000 UTC'>August 24, 2021</span>

</div>
  </header> 
  <div class="post-content"><h2 id="use-cases">Use cases<a hidden class="anchor" aria-hidden="true" href="#use-cases">#</a></h2>
<h3 id="achieve-high-availability-ha-from-the-standpoint-of-users-or-proxies">Achieve high availability (HA) from the standpoint of Users or Proxies<a hidden class="anchor" aria-hidden="true" href="#achieve-high-availability-ha-from-the-standpoint-of-users-or-proxies">#</a></h3>
<p>assuming that:</p>
<ul>
<li>the failure of some attempt is temporary or localized to some of the workers</li>
<li>workers are redundant and interchangeable</li>
<li>there are enough time and workers</li>
</ul>
<p>There are several types or levels of retrying:</p>
<p><img loading="lazy" src="/images/retry-n-timeout/type.png"></p>
<p>A general control flow of retries:
<img loading="lazy" src="/images/retry-n-timeout/workflow.png"></p>
<h3 id="polling-for-a-status-change-without-knowing-when-itll-happen">Polling for a status change without knowing when it&rsquo;ll happen<a hidden class="anchor" aria-hidden="true" href="#polling-for-a-status-change-without-knowing-when-itll-happen">#</a></h3>
<p><img loading="lazy" src="/images/retry-n-timeout/poll.png"></p>
<p>Sleep interval can be linear or exponential, based on your modeling of probability distribution of when the change will happen.</p>
<h2 id="model">Model<a hidden class="anchor" aria-hidden="true" href="#model">#</a></h2>
<p><img loading="lazy" src="/images/retry-n-timeout/model.png"></p>
<p>Evaluate by:</p>
<ul>
<li>error types (can recover by retrying?)</li>
<li>number of attempts (max attempts reached?)</li>
<li>time (timeout?)</li>
</ul>
<blockquote>
<p>The definition of insanity is doing the same thing over and over again, but expecting different results.</p>
<p>&ndash; Albert Einstein</p></blockquote>
<p>Adjust on:</p>
<ul>
<li>time (sleep intervals)</li>
<li>worker (pick another worker / let a load balancer decide)</li>
<li>request size (response 413 or 429: split large requests into smaller ones)</li>
<li>request data (User triggered, e.g. fix typo, input correct values)</li>
</ul>
<h2 id="if-the-clients-are-many">If the clients are many<a hidden class="anchor" aria-hidden="true" href="#if-the-clients-are-many">#</a></h2>
<p>client retry strategy becomes a gaming problem, local optimization may cause overall crisis.</p>
<ul>
<li>request times (i.e wait intervals) should be randomized to avoid workload peaks</li>
<li>resource contention and racing condition should be treated by both clients and the service instances</li>
<li>eliminate unnecessary retries from both client and service side.</li>
</ul>
<h2 id="pros-and-cons-for-client-retries">Pros and cons for client retries<a hidden class="anchor" aria-hidden="true" href="#pros-and-cons-for-client-retries">#</a></h2>
<p>Pros:</p>
<ul>
<li>allows client being resilient to partial / temporary failures</li>
<li>allows client-driven async workflows (write, polling reads, another write)</li>
</ul>
<p>Cons:</p>
<ul>
<li>may incur side effects (non-idempotent writes cause duplicate data)</li>
<li>request multiplication is non-linear and positively related to service load and latency (cascading failures)</li>
<li>may cause racing conditions or hot spots.</li>
</ul>
<p>To remediate the Cons, we need these technical capabilities on the service side:</p>
<ul>
<li>idempotent write APIs</li>
<li>rate limits / circuit breakers / load balancing with warm-ups</li>
<li>locks, queues and sharding</li>
</ul>
<h2 id="anti-patterns--donts-">Anti-patterns ( &ldquo;Don&rsquo;t&quot;s )<a hidden class="anchor" aria-hidden="true" href="#anti-patterns--donts-">#</a></h2>
<h3 id="dont-retry-on-all-errors">Don&rsquo;t retry on all errors<a hidden class="anchor" aria-hidden="true" href="#dont-retry-on-all-errors">#</a></h3>
<p>retry should be based on coded type of errors</p>
<p>http status code:</p>
<ul>
<li>429 too many requests</li>
<li>503 service unavailable</li>
</ul>
<p>see the code in <a href="https://github.com/aws/aws-sdk-go/blob/main/aws/client/default_retryer.go#L168">aws sdk retryer</a></p>
<p><img loading="lazy" src="/images/retry-n-timeout/status-code.png"></p>
<p>GRPC status code:</p>
<ul>
<li>Unavailable</li>
<li>ResourceExhausted</li>
</ul>
<p>see the code in <a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/main/interceptors/retry/options.go#L20">go-grpc retryer</a></p>
<h3 id="dont-retry-instantly">Don&rsquo;t retry instantly<a hidden class="anchor" aria-hidden="true" href="#dont-retry-instantly">#</a></h3>
<p>should wait with backoffs, especially when throttled</p>
<p>see the code in <a href="https://github.com/aws/aws-sdk-go/blob/main/aws/client/default_retryer.go">aws sdk retryer</a></p>
<p>Retry-After in seconds:</p>
<pre tabindex="0"><code>[0.045, 0.06, 0.09, 0.15, 0.27, 0.51, 0.99, 1.95, 3.87, 7.71, 15.39, 30.75, 61.47, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91, 122.91]
</code></pre><h3 id="dont-retry-on-the-fragile-parts">Don&rsquo;t retry on the fragile parts<a hidden class="anchor" aria-hidden="true" href="#dont-retry-on-the-fragile-parts">#</a></h3>
<p>e.g. retry on Services, not on Pods; retry on domain names, not on ips</p>
<h3 id="dont-retry-indefinitely">Don&rsquo;t retry indefinitely<a hidden class="anchor" aria-hidden="true" href="#dont-retry-indefinitely">#</a></h3>
<p>when maximal time or attempts are exceeded:</p>
<ul>
<li>trigger alarms</li>
<li>manually ignore</li>
<li>put to dead letter queue for later processing</li>
</ul>
<h2 id="guidelines-dos">Guidelines (&ldquo;Do&quot;s)<a hidden class="anchor" aria-hidden="true" href="#guidelines-dos">#</a></h2>
<ul>
<li>retry on selected errors at the right level (user vs. client vs. proxy vs. worker)</li>
<li>service should fail fast and explicit (allow downstream to decide should / how to retry)</li>
<li>pass timeouts through context</li>
<li>configurable retry parameters (max attempts, per-attempt timeout, retry-able error codes)</li>
<li>apply back-pressure (TCP flow control, 429 responses, alarm triggering scaling and throttling actions)</li>
<li>idempotent writes (avoid duplicate data)</li>
</ul>
<h2 id="cascading-failures-the-nightmare-of-system-operators-sres">Cascading failures, the nightmare of system operators (SREs)<a hidden class="anchor" aria-hidden="true" href="#cascading-failures-the-nightmare-of-system-operators-sres">#</a></h2>
<p>positive feedback loop</p>
<h3 id="case-1-dynamodb-oos-because-gsi-was-introduced-in-2015">Case 1. DynamoDB OOS because GSI was introduced in 2015<a hidden class="anchor" aria-hidden="true" href="#case-1-dynamodb-oos-because-gsi-was-introduced-in-2015">#</a></h3>
<p><img loading="lazy" src="/images/retry-n-timeout/ddb.png"></p>
<p><a href="https://aws.amazon.com/message/5467D2/">https://aws.amazon.com/message/5467D2/</a></p>
<p><a href="https://www.infoq.com/articles/anatomy-cascading-failure/">https://www.infoq.com/articles/anatomy-cascading-failure/</a></p>
<p>If service capacity is not added quickly enough and the load balancing is naive (round-robin or least-conn), new capacities will be flooded quickly (domino effect)</p>
<p>Lessons learned:</p>
<ul>
<li>avoid resource contention between client-facing requests and administrative ones</li>
<li>sharding on metadata</li>
<li>reduce retries to a lower rate</li>
</ul>
<h3 id="case-2-aws-us-east-1-down-because-kinesis-frontend-fleet-scaling-out-limitations">Case 2. AWS us-east-1 down because Kinesis frontend fleet scaling out limitations<a hidden class="anchor" aria-hidden="true" href="#case-2-aws-us-east-1-down-because-kinesis-frontend-fleet-scaling-out-limitations">#</a></h3>
<p><img loading="lazy" src="/images/retry-n-timeout/kinesis.png"></p>
<p><a href="https://aws.amazon.com/message/11201/">https://aws.amazon.com/message/11201/</a></p>
<p>the issue was identified within 4 hours, but the recovery process (manually restarting servers in batches and ramping up workload) took over 17 hours.</p>
<p>because if service capacity is added too quickly, there are significant resource contentions causing the new capacities to be unhealthy and taken down.</p>
<p>Lessons learned:</p>
<ul>
<li>horizontal scaling may have unknown limits (open file handlers, thread counts, network bandwidth etc) that sometimes vertical scaling is required</li>
<li>avoid resource contention on administrative and client-facing workloads</li>
<li>avoid n-to-n synchronizations</li>
<li>sharding on fleets</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://vindurriel.github.io/en/tags/aws/">Aws</a></li>
      <li><a href="https://vindurriel.github.io/en/tags/prose/">Prose</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://vindurriel.github.io/en/">vindurriel</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
