<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="d3.v5.min.js"></script>
    <script src="d3-simple-slider.min.js"></script>
    <style>
        .hidden {
            display: none;
        }

        div.tooltip {
            color: #222;
            background: #fff;
            border-radius: 3px;
            box-shadow: 0px 0px 2px 0px #a6a6a6;
            padding: .2em;
            text-shadow: #f5f5f5 0 1px 0;
            opacity: 0.9;
            position: absolute;
        }
    </style>
</head>
<body>
<div style="display: flex">
    <svg class="map" width="800" height="500"></svg>
    <svg class="topchart" width="400" height="500"></svg>
</div>
<svg class="bar" width="1200" height="120"></svg>
<div class="slider"></div>
<div class="tooltip"></div>
<script>
    const margin = {top: 10, right: 10, bottom: 10, left: 10};
    const width = 800 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;
    const projection = d3.geoMercator()
        .center([110, 25])
        .scale([600])
        .translate([450, 400])
        .precision([.1]);
    const path = d3.geoPath()
        .projection(projection);
    const svg = d3.select(".map")
        .append("g")
        .attr("width", width)
        .attr("height", height);
    const tooltip = d3.select("div.tooltip");
    var dailyData = {};
    fetch("data.json").then(x => x.json()).then(d => {
        const provinceNameMap = d.province_name_map;
        const numberOfDays = d.days.length;
        const day = d.days[numberOfDays - 1];
        dailyData = day.data;
        const colorPattern = d3.scaleSequential()
            .interpolator(d3.interpolatePlasma)
            .domain([2000, 1e-8]);
        const colorValue = d => d * 10 + 200;
        const color = d => {
            const v = dailyData[d.id] || 0;
            if (v === 0) {
                return "white";
            }
            return colorPattern(colorValue(v));
        };

        const dayValue = {};
        const barData = d.days.map(x => {
            const value = Object.values(x.data ?? {}).reduce((partialSum, a) => partialSum + a, 0) || 0;
            dayValue[x.ts] = value;
            return {ts: x.ts, value: dayValue[x.ts]};
        });

        const xBand = d3
            .scaleBand()
            .domain(barData.map(d => d.ts))
            .range([30, 1200 - 30]);

        const yValue = d3
            .scaleLog()
            .domain([1, d3.max(barData, d => d.value + 1)])
            .nice()
            .range([120, 0]);

        const barColor = (d, selected) => {
            return d.ts === selected ? colorPattern(2000) : colorPattern(colorValue(d.value));
        }
        const barOpacity = (d, selected) => {
            return d.ts === selected ? 1 : .5;
        }
        const bars = d3.select(".bar")
            .append('g')
            .selectAll('rect')
            .data(barData);

        const barsEnter = bars
            .enter()
            .append('rect')
            .attr("fill", d => barColor(d, day.ts))
            .attr("opacity", d => barOpacity(d, day.ts))
            .attr('x', d => xBand(d.ts))
            .attr('y', d => yValue(d.value + 1))
            .attr('height', d => yValue(1) - yValue(d.value + 1))
            .attr('width', xBand.bandwidth());

        const drawTopChart = (topChartData) => {
            const topChart = d3.select(".topchart")
                .selectAll('g')
                .remove()
                .exit()
                .data(topChartData);

            const topChartEnter = topChart.enter()
                .append('g')
                .merge(topChart);

            topChartEnter.append('text')
                .text(d => `${provinceNameMap[d.id]}: ${dailyData[d.id]}`)
                .attr('x', 0)
                .attr("fill", "black")
                .attr('y', (d, i) => i * 40 + 20)
                .attr('font-size', "12px")
                .attr('text-anchor', "right");
            topChartEnter.append('rect')
                .attr('x', 0)
                .attr('y', (d, i) => i * 40 + 25)
                .attr("fill", d => colorPattern(colorValue(d.value)))
                .attr('width', d => Math.log2(d.value + 1) * 30)
                .attr('height', 10);
        };

        const topChartData = (dailyData) => {
            return Object.keys(dailyData).map(id => {
                return {id, value: dailyData[id]};
            }).sort((a, b) => b.value - a.value);
        };

        drawTopChart(topChartData(dailyData));


        const slider = d3.sliderHorizontal()
            .min(0).max(numberOfDays - 1).step(1)
            .width(1200 - 60).height(120)
            .value(numberOfDays - 1)
            .displayValue(true)
            .tickFormat(v => d.days[v].ts)
            .ticks(10)
            .on('onchange', v => {
                const day = d.days[v];
                dailyData = day.data;
                svg.selectAll("path").attr("fill", d => color(d));
                barsEnter.merge(bars)
                    .attr("fill", d => barColor(d, day.ts))
                    .attr("opacity", d => barOpacity(d, day.ts))
                drawTopChart(topChartData(dailyData));
            });

        d3.select('.slider')
            .append('svg')
            .attr('width', 1200)
            .attr('height', 120)
            .append('g')
            .attr('transform', 'translate(30,10)')
            .call(slider);

        const getTooltipText = d => {
            return `${d.properties.name}: ${dailyData[d.id] || 0}`;
        }

        fetch("china.geo.json").then(x => x.json()).then(d => {
            svg.selectAll("path")
                .data(d.features)
                .enter()
                .append("path")
                .attr("stroke", "grey")
                .attr("stroke-width", 1)
                .attr("fill", d => color(d))
                .attr("d", path)
                .on("mouseover", function (d) {
                    d3.select(this).attr("stroke-width", 2);
                    return tooltip.style("hidden", false).text(getTooltipText(d));
                })
                .on("mousemove", function (d) {
                    tooltip.classed("hidden", false)
                        .style("top", (d3.event.pageY) + "px")
                        .style("left", (d3.event.pageX + 10) + "px")
                        .text(getTooltipText(d));
                })
                .on("mouseout", function (d, i) {
                    d3.select(this).attr("fill", color).attr("stroke-width", 1);
                    tooltip.classed("hidden", true);
                });
        });
    });
</script>
</body>
